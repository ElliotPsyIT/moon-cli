#!/usr/bin/env node

var hexu = require("hexu");
var Handlebars = require("handlebars");
var async = require("async");
var fs = require("fs");
var path = require('path');
var readline = require('readline');
var exec = require("child_process").execSync;
var pkg = require("../package.json");
var load = require("../src/loader.js");

var command = process.argv.slice(2);

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

load.defineRl(rl);

const space = (num) => {
  return "\n".repeat(num);
}

const intro = () => {
  console.log(hexu.blue("======= MOON =======") + space(1));
}

const help = () => {
  console.log("    Usage: moon <command> [options]");
  console.log(space(1));
  console.log("    Commands: ");
  console.log("      init\tgenerates a new project");
  console.log("      help\tdisplays this help message");
  console.log(space(1));
  console.log("    Options: ");
  console.log("      -h, --help\tdisplays this help message");
  console.log("      -v, --version\tdisplays current Moon version");
  exit();
}

const version = () => {
  console.log(pkg.version);
  exit();
}

const err = (msg) => {
  console.log("  Moon " + hexu.red("ERR") + "    " + msg);
  exit();
}

const exit = () => {
  rl.close();
}

const mkdirp = (pathToCreate) => {
  if(fs.existsSync(dir)){
    return
  }
  try{
    fs.mkdirSync(dir);
  } catch(err) {
    if(err.code == 'ENOENT'){
      mkdirp(path.dirname(dir));
      mkdirp(dir);
    }
  }
}

var walk = function(dir, done) {
  var results = [];
  fs.readdir(dir, function(err, list) {
    if (err) return done(err);
    var pending = list.length;
    if (!pending) return done(null, results);
    list.forEach(function(file) {
      file = path.resolve(dir, file);
      fs.stat(file, function(err, stat) {
        if (stat && stat.isDirectory()) {
          walk(file, function(err, res) {
            results = results.concat(res);
            if (!--pending) done(null, results);
          });
        } else {
          results.push(file);
          if (!--pending) done(null, results);
        }
      });
    });
  });
};

const info = (cb) => {
  var name = JSON.stringify(exec('git config --get user.name').toString().trim()).slice(1, -1);
  var answers = ask({
    "Author": {
      def: name,
      key: "author"
    },
    "Description": {
      def: "A Moon App",
      key: "description"
    },
    "Moon Version": {
      def: require("moonjs").version,
      key: "version"
    }
  }, function(answers) {
    cb(answers);
  });
}

const ask = (questions, cb) => {
  // Utility to Ask Question
  var prompt, answers = {};
  async.eachSeries(Object.keys(questions), function(question, done) {
    var def = questions[question].def;
    if(def) {
      prompt = "    " + hexu.green("[?]") + " " + question + hexu.grey(" (" + def + ")  ");
    } else {
      prompt = "    " + hexu.green("[?]") + " " + question + "  ";
    }
    rl.question(prompt, (answer) => {
      if(!answer) answer = def;
      readline.moveCursor(rl, 0, -1);
      rl.write("\n");
      readline.moveCursor(rl, 0, -2);
      rl.write(`    ${hexu.green("[?]")} ${question}  ${hexu.cyan(answer)}\n\n`);
      readline.moveCursor(rl, 0, -1);
      rl.write(" ".repeat(prompt.length) + "\n");
      answers[questions[question].key] = answer;
      done(null);
    });
  }, function() {
    cb(answers)
  });
}

var read = function(file, cb) {
  fs.readFile(file, 'utf8', function(err, content) {
    cb(file, content);
  });
}

const compile = (name, opts, cb) => {
  // Walk Files
  walk(path.join(process.cwd(), name), function(err, files) {
    for(var i = 0; i < files.length; i++) {
      var file = files[i];
      var count = -1;
      read(file, function(fileName, content) {
        // Replace special mustache templates
        var compiled = Handlebars.compile(content)(opts);
        fs.writeFile(fileName, compiled, 'utf8', function(err) {
          if(err) {
            err(err);
          }
          count++;
          if(files.length - 1 === count) {
            cb();
          }
        });
      });
    }
  });
}

const init = (name) => {
  // Initialize App
  // Get Info
  info(function(opts) {
    // Create Loader
    var templateLoader = new load(hexu.blue("generating") + " template");
    // Create directory
    mkdirp(name);
    // Copy files from template
    ncp(path.join(__dirname, "/../template"), path.join(process.cwd(), name), function (error) {
      if(error) console.log(error);
      // Compile template
      opts.name = name;
      compile(name, opts, function() {
        // Success
        rl.on('close', function() {
          console.log("\n");
          console.log(`${hexu.green("success")} generated ${hexu.grey(`'${name}'`)} âœ¨`);
          console.log("\n")
          console.log("To Start, Run:");
          console.log(hexu.grey(`  cd ${name}
  npm install
  npm run dev`));
        });
        templateLoader.done(function() {
          // Close Interface when Done
          rl.close();
        });
      });
    });
  });
}

intro();
switch (command[0]) {
  case "--help":
  case "help":
  case undefined:
    help();
    break;
  case "-h":
    help();
    break;
  case "-v":
    version();
    break;
  case "--version":
    version();
    break;
  case "init":
    if(command[1]) {
      init(command[1]);
    } else {
      err("Please provide an app name");
    }
    break;
  default:
    err("Command Not Found");
}
